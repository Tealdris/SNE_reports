###### tags: `SSN`
:::success
# SSN Lab 4 Assignment: Asymmetrical‌ ‌encryption‌
**Name: Radomskiy Ilia**
:::

---

## Task 1: Begining

:::info
1.1. Create‌‌a‌‌ 2048‌‌ bit‌‌ RSA‌‌ key‌‌ pair‌‌ using‌‌‌ OpenSSL
‌
:::

Private RSA key can be generated by using the command below

```
openssl req -newkey rsa:2048 -nodes -keyout first.key
```

From `first.key` private key we can create a public key, with the command listed below


```
openssl rsa -in first.key -pubout -out first_p.key
```

:::info
1.2.  Write‌‌ your‌‌ full‌‌ name‌‌ in‌‌ a‌‌ text‌‌ file‌‌ and‌‌ encrypt‌‌ it‌‌ with‌‌ your‌‌‌ private‌‌ key‌. 
:::

I will encrypt my name in plaintext `Ilya Radomskiy` and in base64 format `SWx5YSBSYWRvbXNraXk=`, to this end I will use two commands below:

To encrypt plaintext
```
openssl rsautl -sign -inkey first.key -in Message_st10.txt -out Message_st10_en.txt
```

To encrypt text in text base64 format
```
openssl rsautl -sign -inkey first.key -in Message_st10_b64.txt -out Message_st10_b64_en.txt
```

:::info
1.3. Using‌‌ OpenSSL‌‌ extract‌‌ the‌‌ public‌‌ modulus‌‌ and‌ ‌the‌ ‌exponent‌ ‌from‌ ‌the‌ ‌public‌ ‌key.‌ ‌
:::

We can see what parts from our public key is consist of:
In web resource

<center>
    
![](https://i.imgur.com/R8bHU4O.png)
ASN.1 Java decoder
</center>

[LINK](https://lapo.it/asn1js/#MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDaVbGRJM5hzEXplmwt9iKRGMckufKWGiq3z-20uGoY07ZEO6_1AmF7rHkfCdAB5s9plXj83LYNfmG92wr2M7Vo4Kc5szBE_QGO1500ToJd5HGdOwgwC04pIZ56foYdLQ-Ue5oam3tvuB1oNJ4enpkATxah0Uk-Eq5NtVkdlwVzZ1RXiMddBs_uEXLmoIZGvV98Vf39-uSbgDTrol6Qh3fkgfoSGUntUmgnKjF2MRMdjj1ULEdXlXPPJv6D7sye5YnYw8K-f-g9I-qZxWLtzoA5b-qquvdc_uDMEpnlXcxbcT8EXAB5Rvk3MDitI5LWm_pj2z_gyzRJ93XAd1odBhkLAgMBAAECggEAZooWcd9CWiXws6qktdVCGLj1VidKafpyE4_AyL5Pfcd4c4VAtyXeGJJA9DXMjggTYzgC8WbKzX2Mc_j6pfRU_6N6hhvE0LGuWKKkvxscGPKf9ULzLnUwyRpz7n2biPpPteFy14osJ6TlkrobhK_hlYaPT4IWDuQBHpfL-Zyiv7ZqgOIA62_AScaJVOM3E5D8Ra0fn1RwUYxMQYdViaIBPRdY44BubaXwKYQisu77xD9bOiO7Hc7Ct8oGaBIydlE6Z-Cz_GqqZz5gAnCq0UtRXJQejnAnXjCvZhMFG1nvwgNAIBO8MazJbP4RupRxJDZ5pdghKJ8RvHveZlv_ExUPMQKBgQDyOuLvYYilqlWtJ9Z6JEFCbmFTooUMt9NF3cMTg1C1IPuumTbI6A-gpxfojNVResOp2B-Z4lCyn2X6Wv4DCJA7tYRuCc6LBB3H7QvoSr4DEvFSvlrKPjta0yJz_2EPx2QmFHD8DkBudTsUgu5_qXl0DUASgfpWI5UyiUnFkMSQ8wKBgQDmvxCj5TrhRF3351tV2E9iUwUQlyltJPyS-4LLlp7YZXvQqutar2fxXbffklYnKfsLtTcPiku-wvkuhxrNZG6ANRIRpnkZRUs-BhKBhAf9y7tCV2XGg62G_1jnVycjO0nJvI87ojP8u3Ul0qyMOuL7Ng_rbrM9BX3xlkrFRTMdiQKBgQDt5P9zciqt6TfzsyhlFK4y_A0CAp8A-pi4CS_JPjJJcXc85qRzc9XFRdWpQodOWm9Ho0aF70qp4vpYgnztpb9hpMfG-kKrLQPCkgAbxywOANCZHvIzpiLM9IblvW4p_P1SmMjOA4Er-l5nqp9pKZxqaYj_pD-j0ZZ553NYYPFsGQKBgQCJ_UjeOn9zp4bqcZjVRX5ztmIZAczsUGobG_2j8ncbwdTBfPUyTiNC3GDRepm64ggXgE9lI7cYZVDO2kzU93J9iT88_uj8i8vrU4ZNnb-JrwRVMB7VEHn9eUaZUi09jH8b_X9Kkj20rgXokIxPcAe9Yx8yFAlsPJSMnOwp_LAMwQKBgGzk_WMJoRqoDoOienaw250phiXaEH_J7B10z_0Phrn5oYzDZnpy4y9ElXGwPhcq4-rQUVIYpv0QKsE9j1C3XqabV-whfRonSqxU7qZczU4DjO3pssZQGgKbLPohX7Vu05YXKzkdXO7GWRAuobsKQS3itIvzXH3_ePZNNHcQ9Yf5)

Or by using openssl

<center>
    
![](https://i.imgur.com/6n31zom.png)
openssl 
</center>
    
So, from this we can tell that my public key consists from:
Modulus integer 2048 bit of data
Exponent integer 65537

:::info
1.4. Publish‌ ‌your‌ ‌public‌ ‌key‌ ‌and‌ ‌the‌ ‌`base64`‌‌ formated‌ ‌encrypted‌ ‌text‌ ‌in‌ ‌your‌ ‌report.‌ ‌
:::

You can see my ‌public‌ ‌key‌ ‌and‌ ‌the‌ ‌‌ ‌encrypted‌ ‌text‌ (in hex format) in the two pictures below

<center>
    
![](https://i.imgur.com/0z82Lae.png)
Public key
</center>

<center>
    
![](https://i.imgur.com/jN99DYI.png)
Encryptd text
</center>

I will also provide them as files in moodle

:::info
1.5. Verify‌ ‌that‌ ‌it‌ ‌is‌ ‌enough‌ ‌for‌ ‌decryption.‌ ‌
:::spoiler
Hint:‌ ‌study‌ ‌openssl‌ ‌params‌ ‌and‌ ‌encryption‌ ‌vs‌ ‌verification‌ ‌vs‌ ‌decryption‌ ‌vs‌ ‌signing‌ ‌
:::

For decryption can be used two commands listed below. First for decryption of plaintext, second for decryption of text in base64 format

plaintext decryption:
```
openssl rsautl -verify -pubin -inkey first_p.key -in Message_st10_en.txt -out decryptrd.txt
```

text in base64 format decryption:
```
openssl rsautl -verify -pubin -inkey first_p.key -in Message_st10_b64_en.txt -out decryptrd_b64.txt
```

On the picture below you can see two resulting  files, for plaintext and for text in format base64

<center>
    
![](https://i.imgur.com/onW2YiA.png)
Two decrypted files
</center>

---

## Task 2: Assumptions

:::info
2.1. Assuming‌‌ that‌‌ you‌‌ are‌‌ generating‌‌ a‌‌ 1024‌‌ bit‌‌ RSA‌‌ key‌‌ and‌‌ the‌‌ prime‌‌ factors‌‌ have‌‌ a‌‌ 512‌‌ bit‌‌ length,‌‌ what‌‌ is‌‌ the‌‌ probability‌‌ of‌‌ picking‌‌ the‌‌ same‌‌ prime‌‌ factor‌‌ twice?‌‌
:::

The probability of picking two same prime numbers twice with length 512 is equal to: 2.6572603484047184e-152

:::info
2.2 Explain‌ ‌your‌ ‌answer.
:::

To solve this I wrote a python script

You can see the code on the picture below

<center>

![](https://i.imgur.com/NEt7Eoy.png)

Code in python
</center>
    
<center>
    
![](https://i.imgur.com/1hSSVS1.png)
Output
</center>
    
First step is to calculate how many prime numbers is there is we are talking about number with a length of 512
According to this [Prime number theorem](https://en.m.wikipedia.org/wiki/Prime_number_theorem) we can calculate the amount of prime numbers using this formula

![](https://i.imgur.com/Fj75QNY.png)

after we know how many prime numbers before `2^512` (10...00 (min number with len 512)) and before ( `(2^513)-1)` (11...11 (max number with len 512)) exists. 
We can subtract these numbers in order to know how many prime numbers with length 512 exists

Then we need to find the probability of 1 exact number being chosen twice:
So probability of picking any one number from all prime numbers is
`1` or 
```
(difference in prime numbers)/(difference in prime numbers)
```

The probability of picking only one particular number is equal to 
```
(1)/(difference in prime numbers)
```

Because of two situations is depending of each other, we need to multiply them
And in the result, we are getting the probability of picking two same numbers
`2.6572603484047184e-152`

---

## Task 3: Practical 1

:::info
3.1. find‌ ‌the‌‌ modulus‌‌ (public‌‌ information)‌‌ of‌‌ two‌‌ related‌‌ 1024 bit‌‌ RSA‌ ‌keys.‌
:::spoiler
Your‌ ‌keys‌ ‌are‌ ‌numbered‌ ‌using‌ ‌ the‌ ‌list‌.‌
:::

My list number is `10` so my keys are

```
0xde9e10a438016ead23e753e3488113c100cbfe4c1b0e31c908d25b5fb663438bd6c96199ad6cb19a1472a2143d3d16db6f227ec866b3b1487cce0e60224ccfd1cf16379fe352e6582d26472297234a319b26a6218f80a9fb7b7d86a23876355d76fc8f49be053202f99c35f63d63b0e7a99393ef20095b87280b7793abc5febdL
```
```
0xcde3e5c9b26d913871eeb2e1c66407cc5204c54563f816e464ce3d3a989d7169cc5f905127484294914dfb0a03c73686e85a2b73d7b10bc1637cd4417dda37a9027a7291a195a84ecb1bc1d5537ceb19b95220afa2ea608f71d1cf2d68900e5e73b1c62afdb2735e8bbe6341134611f3858252e982befe394aa37f8e35e06a6bL
```

:::info
3.2. ‌factor‌ ‌them‌ ‌i.e.‌‌ retrieve‌ `p` ‌and‌ `q`. ‌ ‌You‌ ‌may‌ ‌use‌ ‌any‌ ‌tools‌ ‌for‌ ‌this.‌ ‌Explain‌ ‌your‌ ‌approach.‌ ‌
:::spoiler
Hints:‌‌ study‌‌ the‌‌ RSA‌‌ algorithm.‌‌ What‌‌ private‌‌ information‌‌ can‌‌ two‌‌ keys‌‌ share?‌‌ What‌‌ practical‌‌ attacks‌‌ exist?‌‌ You‌‌ may‌‌ have‌‌ to‌‌ write‌‌ code‌‌ or‌‌ use‌‌ existing‌‌ code‌‌ for‌‌ simple‌‌ arithmetic‌‌ operations.‌ ‌Be‌ ‌careful‌ ‌with‌ ‌bigInt‌ ‌values!‌
:::

As we are getting that modulus we know that they are related somehow.

So the first thing to try is to assume that `gcd` of the is equal to `p` or `q` or numbers that are used to calculate modulo: `n = pq`

To this end python code was written, you can find it in the picture below

<center>
    
![](https://i.imgur.com/5PYfzWE.png)
Python code for this task
</center>

gcd of given modulo is:
```
12299273442936068281693548953380994272842706534026096342133613289180656269701040114279670583097635100739257866373383750279904544019720903866005027424081051
```
Let's assume that this is `q` number

And from this point we can calculate `p`, in order to do this I was using [Java Big Int Calculator](http://www.javascripter.net/math/calculators/100digitbigintcalculator.htm)
because python for properly with the big numbers

Calculated numbers are:
`p` of first modulo
```
12710286049046806786040554496458598658675176233897852293984071919249089792410477128437074016978765234666474102374561446699447349140458072712234826293736327
```

`p` of second modulo
```
11755249894610062955463596436701513678230636426446312239999310472786962741459626245240500802704220461616696980031200955576223714476105607510784627624116224
```

[RSA wiki](https://en.wikipedia.org/wiki/RSA_(cryptosystem))


---

## Task 4: Practical 2

:::info
4.1. Now‌ ‌that‌ ‌you‌ ‌have‌ ‌the‌ `p‌` ‌and‌ ‌ `q‌` ‌for‌ ‌both‌ ‌keys,‌ ‌recreate‌ ‌the‌ ‌first‌‌ public‌‌ and‌‌ private‌ ‌key‌ ‌using‌ ‌script‌.‌ ‌
:::

For key creation from `n`, `p`, `q` and `e` i will be using [Cosu/rsakey.py](https://gist.github.com/cosu/4058678) file, it is python code from GitHub, you can see part of it on the picture below

<center>
    
![](https://i.imgur.com/Nfw2ugD.png)
rsakey.py programm

</center>

After entering my numbers, that was calculated in previous task, I can get `RSA PRIVATE KEY` and `PUBLIC KEY` as result, you can find them below

```
b'-----BEGIN RSA PRIVATE KEY-----\n\n-----END RSA PRIVATE KEY-----'
```
```
b'-----BEGIN PUBLIC KEY-----\n\n-----END PUBLIC KEY-----'
```


:::info
4.2 Encrypt‌ ‌your‌ ‌name‌ ‌with‌ ‌the‌ ‌private‌ ‌key‌
:::

Unfortunately, this code is originally is created on python2, and not fully supported with python3, so after generating key process, I save keys in different files and encrypt my name with them using `openssl`
I have used commands that are shown below

```
openssl rsautl -sign -inkey second.key -in Message_st10_b64.txt -out Message_st10_b64_en_second.txt
```

```
openssl rsautl -verify -pubin -inkey second_p.key -in Message_st10_b64_en_second.txt -out decryptrd_b64_second.txt
```

As a result, I got the encrypted file, on the picture below you can see encrypted file itself, and information that was decrypted in order to prove that this is valid key pair

<center>
    
![](https://i.imgur.com/g8Bg1zK.png)
Encrypted file and its decrypted version if base64 format
</center>

:::info
‌4.‌3 ‌‌post‌ ‌the‌‌ public‌ ‌key‌ ‌and the‌ ‌base64‌ ‌formatted‌ ‌encrypted‌ ‌data‌ ‌in‌ ‌your‌ ‌report.‌ ‌
:::

My results will be published in moodle with the names:

---

## Task 5: Group project

![](https://i.imgur.com/4VWkCJb.png)

:::info
Stage 1:
Create‌ ‌your‌ ‌PGP‌ ‌keys‌ ‌and‌ ‌exchange‌ ‌and‌ ‌sign‌‌ each‌‌ other's‌‌ keys as‌‌ in‌‌ the‌ ‌picture‌ ‌above.
Verify‌‌ that‌‌ you‌‌ can‌‌ communicate‌ ‌securely‌ ‌with‌ ‌that‌ ‌person.‌
:::

For this task, we will create gpg keys for each student of 4.

GPG key can be created and sent to the server like in the pictures below

<center>
    
![](https://i.imgur.com/NkPYypm.png)
Create key
![](https://i.imgur.com/5Er6hEm.png)
Send key to the server
</center>

Then I have received keys from some of my group mates, Vladimir and Ivan, I performed it with commands shown in the pictures below.
After signing their keys with mine I send them back to the server

<center>
    
![](https://i.imgur.com/bvxbuqg.png)
    Recieve Vladimir's key
![](https://i.imgur.com/zkmqfsR.png)
    Signing and Sending Vladimir's key
</center>

<center>

![](https://i.imgur.com/GTEwUIp.png)
    Recieve Ivan's key
![](https://i.imgur.com/vabT2h1.png)
    Signing Ivan's key
![](https://i.imgur.com/wcD0GVR.png)
    Sending Ivan's key
</center>

Now i can see keys that are stored on my computer

<center>
    
![](https://i.imgur.com/gj7Nr4y.png)
List of all keys on pc
</center>

In general, I know about some of student's GPG keys:

2 A - ?
3 Iv - 5A9F476CB93AD0E7BA7BABD18EAEAC08F8856EF8
4 Il - 46D48A64C97910D23E4ADED41518B420223D9541
1 V - C47A92C1524EDC81572D34357185762BA9AD4F49

:::info
Stage 2:
Obtain‌‌ a‌‌ public‌‌ key‌‌ of‌‌ a‌‌ person‌‌ that‌‌ you‌‌ have‌‌ not‌‌ contacted‌‌ yet‌‌
Send‌‌ them‌‌ a‌‌ private‌‌ message‌‌ alongside‌‌ your‌‌ public‌‌ key.‌‌ At‌‌ this‌‌ point‌‌ you‌‌ do‌‌ not‌‌ need‌‌ to‌ ‌sign‌ ‌each‌ ‌other's‌ ‌keys,‌ ‌since‌ ‌your‌ ‌keys‌ ‌are‌ ‌already‌ ‌signed‌ ‌by‌ ‌2‌ ‌other‌ ‌trusted‌‌
members,‌ ‌so‌ ‌you‌ ‌should‌ ‌be‌ ‌able‌ ‌to‌ ‌securely‌ ‌communicate‌ ‌without‌ ‌it.‌ ‌
Describe‌ ‌what‌ ‌you‌ ‌have‌ ‌done‌ ‌to‌ ‌implement‌ ‌this‌ ‌model
:::

In this step, I have encrypted a message and sent it to the student (Alisher) that don't sign my key, and I have not signed his key
I can encrypt messages to user Alisher with his id, and the command for this is listed below

```
gpg --encrypt --sign --armor --user F28D918639E7265CFFE38F8C7F2D501C900C8AB0 Message_st10.txt
```

<center>
    
![](https://i.imgur.com/FkNkhpg.png)

</center>

In the picture below you can see the difference between messages with  signed and non-signed keys
Alisher's key is not signed, and it is the last key on a list

<center>

![](https://i.imgur.com/lo6Rc7a.png)
List of keys
</center>

On the two pictures below you can see two messages, first one is from Ivan, I signed his key and he signed mine, second is from Alisher's, his key is signed by Vladimir's and Ivan's

<center>

![](https://i.imgur.com/Pta6lXi.png)
Message from ivan
</center>

<center>
    
![](https://i.imgur.com/lf08SdI.png)
Message from Alisher
</center>
    
[gpg man](https://www.gnupg.org/documentation/manpage.html)
[GPG to Encrypt and Sign Messages](https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages)
:::

---
## References:

